/*
 * Invoices
 * Use the Invoicing API to create, send, and manage invoices. You can also use the API or webhooks to track invoice payments. When you send an invoice to a customer, the invoice moves from draft to payable state. PayPal then emails the customer a link to the invoice on the PayPal website. Customers with a PayPal account can log in and pay the invoice with PayPal. Alternatively, customers can pay as a guest with a debit card or credit card. For more information, see the <a href=\"/docs/invoicing/\">Invoicing Overview</a> and the <a href=\"/docs/invoicing/basic-integration/\">Invoicing Integration Guide</a>.
 *
 * The version of the OpenAPI document: 2.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package io.sinistral.s1.payments.paypal.api;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.sinistral.s1.payments.paypal.core.ApiClient;
import io.sinistral.s1.payments.paypal.core.ApiException;
import io.sinistral.s1.payments.paypal.core.ApiResponse;
import io.sinistral.s1.payments.paypal.core.Pair;
import io.sinistral.s1.payments.paypal.models.*;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.StringJoiner;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;

@jakarta.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-09-21T16:02:23.639524-07:00[America/Los_Angeles]")
public class InvoicesApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public InvoicesApi() {
    this(new ApiClient());
  }

  public InvoicesApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  private ApiException getApiException(String operationId, HttpResponse<String> response) {
    String message = formatExceptionMessage(operationId, response.statusCode(), response.body());
    return new ApiException(response.statusCode(), message, response.headers(), response.body());
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Cancel sent invoice
   * Cancels a sent invoice, by ID, and, optionally, sends a notification about the cancellation to the payer, merchant, and CC: emails.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param notification The email or SMS notification that will be sent to the payer on cancellation. (required)
   * @return CompletableFuture&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Void> invoicesCancel(String invoiceId, Notification notification) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesCancelRequestBuilder(invoiceId, notification);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesCancel", localVarResponse));
            }
            return CompletableFuture.completedFuture(null);
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Cancel sent invoice
   * Cancels a sent invoice, by ID, and, optionally, sends a notification about the cancellation to the payer, merchant, and CC: emails.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param notification The email or SMS notification that will be sent to the payer on cancellation. (required)
   * @return CompletableFuture&lt;ApiResponse&lt;Void&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Void>> invoicesCancelWithHttpInfo(String invoiceId, Notification notification) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesCancelRequestBuilder(invoiceId, notification);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesCancel", localVarResponse));
            }
            return CompletableFuture.completedFuture(
                new ApiResponse<Void>(localVarResponse.statusCode(), localVarResponse.headers().map(), null)
            );
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesCancelRequestBuilder(String invoiceId, Notification notification) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesCancel");
    }
    // verify the required parameter 'notification' is set
    if (notification == null) {
      throw new ApiException(400, "Missing the required parameter 'notification' when calling invoicesCancel");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}/cancel"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(notification);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Create draft invoice
   * Creates a draft invoice. To move the invoice from a draft to payable state, you must &lt;a href&#x3D;\&quot;#invoices_send\&quot;&gt;send the invoice&lt;/a&gt;.&lt;br/&gt;&lt;br/&gt;In the JSON request body, include invoice details including merchant information. The &lt;code&gt;invoice&lt;/code&gt; object must include an &lt;code&gt;items&lt;/code&gt; array.&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt; The merchant that you specify in an invoice must have a PayPal account in good standing.&lt;/blockquote&gt;.
   * @param invoice The invoice details which includes all information of the invoice like items, billing information. (required)
   * @return CompletableFuture&lt;Invoice&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Invoice> invoicesCreate(Invoice invoice) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesCreateRequestBuilder(invoice);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesCreate", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<Invoice>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Create draft invoice
   * Creates a draft invoice. To move the invoice from a draft to payable state, you must &lt;a href&#x3D;\&quot;#invoices_send\&quot;&gt;send the invoice&lt;/a&gt;.&lt;br/&gt;&lt;br/&gt;In the JSON request body, include invoice details including merchant information. The &lt;code&gt;invoice&lt;/code&gt; object must include an &lt;code&gt;items&lt;/code&gt; array.&lt;blockquote&gt;&lt;strong&gt;Note:&lt;/strong&gt; The merchant that you specify in an invoice must have a PayPal account in good standing.&lt;/blockquote&gt;.
   * @param invoice The invoice details which includes all information of the invoice like items, billing information. (required)
   * @return CompletableFuture&lt;ApiResponse&lt;Invoice&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Invoice>> invoicesCreateWithHttpInfo(Invoice invoice) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesCreateRequestBuilder(invoice);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesCreate", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<Invoice>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<Invoice>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesCreateRequestBuilder(Invoice invoice) throws ApiException {
    // verify the required parameter 'invoice' is set
    if (invoice == null) {
      throw new ApiException(400, "Missing the required parameter 'invoice' when calling invoicesCreate");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, multipart/mixed");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(invoice);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Delete invoice
   * Deletes a draft or scheduled invoice, by ID. Deletes invoices in the draft or scheduled state only. For invoices that have already been sent, you can &lt;a href&#x3D;\&quot;/docs/api/invoicing/v2/#invoices_cancel\&quot;&gt;cancel the invoice&lt;/a&gt;. After you delete a draft or scheduled invoice, you can no longer use it or show its details. However, you can reuse its invoice number.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @return CompletableFuture&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Void> invoicesDelete(String invoiceId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesDeleteRequestBuilder(invoiceId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesDelete", localVarResponse));
            }
            return CompletableFuture.completedFuture(null);
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Delete invoice
   * Deletes a draft or scheduled invoice, by ID. Deletes invoices in the draft or scheduled state only. For invoices that have already been sent, you can &lt;a href&#x3D;\&quot;/docs/api/invoicing/v2/#invoices_cancel\&quot;&gt;cancel the invoice&lt;/a&gt;. After you delete a draft or scheduled invoice, you can no longer use it or show its details. However, you can reuse its invoice number.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @return CompletableFuture&lt;ApiResponse&lt;Void&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Void>> invoicesDeleteWithHttpInfo(String invoiceId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesDeleteRequestBuilder(invoiceId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesDelete", localVarResponse));
            }
            return CompletableFuture.completedFuture(
                new ApiResponse<Void>(localVarResponse.statusCode(), localVarResponse.headers().map(), null)
            );
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesDeleteRequestBuilder(String invoiceId) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesDelete");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Generate QR code
   * Generates a QR code for an invoice, by ID. The QR code is a PNG image in &lt;a href&#x3D;\&quot;https://www.base64encode.org/\&quot;&gt;Base64-encoded&lt;/a&gt; format that corresponds to the invoice ID. You can generate a QR code for an invoice and add it to a paper or PDF invoice. When customers use their mobile devices to scan the QR code, they are redirected to the PayPal mobile payment flow where they can view the invoice and pay online with PayPal or a credit card. Before you get a QR code, you must &lt;a href&#x3D;\&quot;#invoices_create\&quot;&gt;create an invoice&lt;/a&gt; and &lt;a href&#x3D;\&quot;#invoices_send\&quot;&gt;send an invoice&lt;/a&gt; to move the invoice from a draft to payable state. Do not include an email address if you do not want the invoice emailed.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param qrConfig Optional configuration parameters to adjust QR code width, height and the encoded URL. (optional)
   * @return CompletableFuture&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Void> invoicesGenerateQrCode(String invoiceId, QrConfig qrConfig) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesGenerateQrCodeRequestBuilder(invoiceId, qrConfig);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesGenerateQrCode", localVarResponse));
            }
            return CompletableFuture.completedFuture(null);
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Generate QR code
   * Generates a QR code for an invoice, by ID. The QR code is a PNG image in &lt;a href&#x3D;\&quot;https://www.base64encode.org/\&quot;&gt;Base64-encoded&lt;/a&gt; format that corresponds to the invoice ID. You can generate a QR code for an invoice and add it to a paper or PDF invoice. When customers use their mobile devices to scan the QR code, they are redirected to the PayPal mobile payment flow where they can view the invoice and pay online with PayPal or a credit card. Before you get a QR code, you must &lt;a href&#x3D;\&quot;#invoices_create\&quot;&gt;create an invoice&lt;/a&gt; and &lt;a href&#x3D;\&quot;#invoices_send\&quot;&gt;send an invoice&lt;/a&gt; to move the invoice from a draft to payable state. Do not include an email address if you do not want the invoice emailed.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param qrConfig Optional configuration parameters to adjust QR code width, height and the encoded URL. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;Void&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Void>> invoicesGenerateQrCodeWithHttpInfo(String invoiceId, QrConfig qrConfig) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesGenerateQrCodeRequestBuilder(invoiceId, qrConfig);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesGenerateQrCode", localVarResponse));
            }
            return CompletableFuture.completedFuture(
                new ApiResponse<Void>(localVarResponse.statusCode(), localVarResponse.headers().map(), null)
            );
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesGenerateQrCodeRequestBuilder(String invoiceId, QrConfig qrConfig) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesGenerateQrCode");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}/generate-qr-code"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "multipart/mixed, application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(qrConfig);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Show invoice details
   * Shows details for an invoice, by ID.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @return CompletableFuture&lt;Invoice&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Invoice> invoicesGet(String invoiceId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesGetRequestBuilder(invoiceId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesGet", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<Invoice>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Show invoice details
   * Shows details for an invoice, by ID.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @return CompletableFuture&lt;ApiResponse&lt;Invoice&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Invoice>> invoicesGetWithHttpInfo(String invoiceId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesGetRequestBuilder(invoiceId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesGet", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<Invoice>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<Invoice>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesGetRequestBuilder(String invoiceId) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesGet");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * List invoices
   * Lists invoices. To filter the invoices that appear in the response, you can specify one or more optional query parameters.
   * @param page The page number to be retrieved, for the list of templates. So, a combination of &#x60;page&#x3D;1&#x60; and &#x60;page_size&#x3D;20&#x60; returns the first 20 templates. A combination of &#x60;page&#x3D;2&#x60; and &#x60;page_size&#x3D;20&#x60; returns the next 20 templates. (optional, default to 1)
   * @param pageSize The maximum number of templates to return in the response. (optional, default to 20)
   * @param totalRequired Indicates whether the to show &lt;code&gt;total_pages&lt;/code&gt; and &lt;code&gt;total_items&lt;/code&gt; in the response. (optional, default to false)
   * @param fields The fields to return in the response. Value is &#x60;all&#x60; or &#x60;none&#x60;. To return only the template name, ID, and default attributes, specify &#x60;none&#x60;. (optional, default to all)
   * @return CompletableFuture&lt;Invoices&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Invoices> invoicesList(Integer page, Integer pageSize, Boolean totalRequired, String fields) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesListRequestBuilder(page, pageSize, totalRequired, fields);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesList", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<Invoices>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * List invoices
   * Lists invoices. To filter the invoices that appear in the response, you can specify one or more optional query parameters.
   * @param page The page number to be retrieved, for the list of templates. So, a combination of &#x60;page&#x3D;1&#x60; and &#x60;page_size&#x3D;20&#x60; returns the first 20 templates. A combination of &#x60;page&#x3D;2&#x60; and &#x60;page_size&#x3D;20&#x60; returns the next 20 templates. (optional, default to 1)
   * @param pageSize The maximum number of templates to return in the response. (optional, default to 20)
   * @param totalRequired Indicates whether the to show &lt;code&gt;total_pages&lt;/code&gt; and &lt;code&gt;total_items&lt;/code&gt; in the response. (optional, default to false)
   * @param fields The fields to return in the response. Value is &#x60;all&#x60; or &#x60;none&#x60;. To return only the template name, ID, and default attributes, specify &#x60;none&#x60;. (optional, default to all)
   * @return CompletableFuture&lt;ApiResponse&lt;Invoices&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Invoices>> invoicesListWithHttpInfo(Integer page, Integer pageSize, Boolean totalRequired, String fields) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesListRequestBuilder(page, pageSize, totalRequired, fields);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesList", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<Invoices>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<Invoices>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesListRequestBuilder(Integer page, Integer pageSize, Boolean totalRequired, String fields) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices";

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "page";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("page", page));
    localVarQueryParameterBaseName = "page_size";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("page_size", pageSize));
    localVarQueryParameterBaseName = "total_required";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("total_required", totalRequired));
    localVarQueryParameterBaseName = "fields";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fields", fields));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json, multipart/mixed");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Record payment for invoice
   * Records a payment for the invoice. If no payment is due, the invoice is marked as &#x60;PAID&#x60;. Otherwise, the invoice is marked as &#x60;PARTIALLY PAID&#x60;.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param paymentDetail The details of the payment to record against the invoice. (required)
   * @return CompletableFuture&lt;PaymentReference&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<PaymentReference> invoicesPayments(String invoiceId, PaymentDetail paymentDetail) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesPaymentsRequestBuilder(invoiceId, paymentDetail);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesPayments", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<PaymentReference>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Record payment for invoice
   * Records a payment for the invoice. If no payment is due, the invoice is marked as &#x60;PAID&#x60;. Otherwise, the invoice is marked as &#x60;PARTIALLY PAID&#x60;.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param paymentDetail The details of the payment to record against the invoice. (required)
   * @return CompletableFuture&lt;ApiResponse&lt;PaymentReference&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<PaymentReference>> invoicesPaymentsWithHttpInfo(String invoiceId, PaymentDetail paymentDetail) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesPaymentsRequestBuilder(invoiceId, paymentDetail);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesPayments", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<PaymentReference>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<PaymentReference>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesPaymentsRequestBuilder(String invoiceId, PaymentDetail paymentDetail) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesPayments");
    }
    // verify the required parameter 'paymentDetail' is set
    if (paymentDetail == null) {
      throw new ApiException(400, "Missing the required parameter 'paymentDetail' when calling invoicesPayments");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}/payments"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, multipart/mixed");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(paymentDetail);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Delete external payment
   * Deletes an external payment, by invoice ID and transaction ID.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param transactionId The ID of the external refund transaction to delete. (required)
   * @return CompletableFuture&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Void> invoicesPaymentsDelete(String invoiceId, String transactionId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesPaymentsDeleteRequestBuilder(invoiceId, transactionId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesPaymentsDelete", localVarResponse));
            }
            return CompletableFuture.completedFuture(null);
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Delete external payment
   * Deletes an external payment, by invoice ID and transaction ID.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param transactionId The ID of the external refund transaction to delete. (required)
   * @return CompletableFuture&lt;ApiResponse&lt;Void&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Void>> invoicesPaymentsDeleteWithHttpInfo(String invoiceId, String transactionId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesPaymentsDeleteRequestBuilder(invoiceId, transactionId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesPaymentsDelete", localVarResponse));
            }
            return CompletableFuture.completedFuture(
                new ApiResponse<Void>(localVarResponse.statusCode(), localVarResponse.headers().map(), null)
            );
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesPaymentsDeleteRequestBuilder(String invoiceId, String transactionId) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesPaymentsDelete");
    }
    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      throw new ApiException(400, "Missing the required parameter 'transactionId' when calling invoicesPaymentsDelete");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}/payments/{transaction_id}"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()))
        .replace("{transaction_id}", ApiClient.urlEncode(transactionId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Record refund for invoice
   * Records a refund for the invoice. If all payments are refunded, the invoice is marked as &#x60;REFUNDED&#x60;. Otherwise, the invoice is marked as &#x60;PARTIALLY REFUNDED&#x60;.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param refundDetail The details of the refund to record against the invoice. (required)
   * @return CompletableFuture&lt;RefundReference&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<RefundReference> invoicesRefunds(String invoiceId, RefundDetail refundDetail) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesRefundsRequestBuilder(invoiceId, refundDetail);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesRefunds", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<RefundReference>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Record refund for invoice
   * Records a refund for the invoice. If all payments are refunded, the invoice is marked as &#x60;REFUNDED&#x60;. Otherwise, the invoice is marked as &#x60;PARTIALLY REFUNDED&#x60;.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param refundDetail The details of the refund to record against the invoice. (required)
   * @return CompletableFuture&lt;ApiResponse&lt;RefundReference&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<RefundReference>> invoicesRefundsWithHttpInfo(String invoiceId, RefundDetail refundDetail) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesRefundsRequestBuilder(invoiceId, refundDetail);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesRefunds", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<RefundReference>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<RefundReference>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesRefundsRequestBuilder(String invoiceId, RefundDetail refundDetail) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesRefunds");
    }
    // verify the required parameter 'refundDetail' is set
    if (refundDetail == null) {
      throw new ApiException(400, "Missing the required parameter 'refundDetail' when calling invoicesRefunds");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}/refunds"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, multipart/mixed");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(refundDetail);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Delete external refund
   * Deletes an external refund, by invoice ID and transaction ID.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param transactionId The ID of the external refund transaction to delete. (required)
   * @return CompletableFuture&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Void> invoicesRefundsDelete(String invoiceId, String transactionId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesRefundsDeleteRequestBuilder(invoiceId, transactionId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesRefundsDelete", localVarResponse));
            }
            return CompletableFuture.completedFuture(null);
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Delete external refund
   * Deletes an external refund, by invoice ID and transaction ID.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param transactionId The ID of the external refund transaction to delete. (required)
   * @return CompletableFuture&lt;ApiResponse&lt;Void&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Void>> invoicesRefundsDeleteWithHttpInfo(String invoiceId, String transactionId) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesRefundsDeleteRequestBuilder(invoiceId, transactionId);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesRefundsDelete", localVarResponse));
            }
            return CompletableFuture.completedFuture(
                new ApiResponse<Void>(localVarResponse.statusCode(), localVarResponse.headers().map(), null)
            );
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesRefundsDeleteRequestBuilder(String invoiceId, String transactionId) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesRefundsDelete");
    }
    // verify the required parameter 'transactionId' is set
    if (transactionId == null) {
      throw new ApiException(400, "Missing the required parameter 'transactionId' when calling invoicesRefundsDelete");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}/refunds/{transaction_id}"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()))
        .replace("{transaction_id}", ApiClient.urlEncode(transactionId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json, multipart/mixed");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Send invoice reminder
   * Sends a reminder to the payer about an invoice, by ID. In the JSON request body, include a &#x60;notification&#x60; object that defines the subject of the reminder and other details.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param notification The email or SMS notification that will be sent to the payer for reminder. (optional)
   * @return CompletableFuture&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Void> invoicesRemind(String invoiceId, Notification notification) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesRemindRequestBuilder(invoiceId, notification);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesRemind", localVarResponse));
            }
            return CompletableFuture.completedFuture(null);
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Send invoice reminder
   * Sends a reminder to the payer about an invoice, by ID. In the JSON request body, include a &#x60;notification&#x60; object that defines the subject of the reminder and other details.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param notification The email or SMS notification that will be sent to the payer for reminder. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;Void&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Void>> invoicesRemindWithHttpInfo(String invoiceId, Notification notification) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesRemindRequestBuilder(invoiceId, notification);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesRemind", localVarResponse));
            }
            return CompletableFuture.completedFuture(
                new ApiResponse<Void>(localVarResponse.statusCode(), localVarResponse.headers().map(), null)
            );
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesRemindRequestBuilder(String invoiceId, Notification notification) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesRemind");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}/remind"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, multipart/mixed");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(notification);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Send invoice
   * Sends or schedules an invoice, by ID, to be sent to a customer. The action depends on the invoice issue date:&lt;ul&gt;&lt;li&gt;If the invoice issue date is current or in the past, sends the invoice immediately.&lt;/li&gt;&lt;li&gt;If the invoice issue date is in the future, schedules the invoice to be sent on that date.&lt;/li&gt;&lt;/ul&gt;To suppress the merchant&#39;s email notification, set the &#x60;send_to_invoicer&#x60; body parameter to &#x60;false&#x60;. To send the invoice through a share link and not through PayPal, set the &lt;code&gt;send_to_recipient&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt; in the &lt;code&gt;notification&lt;/code&gt; object. The &lt;code&gt;send_to_recipient&lt;/code&gt; parameter does not apply to a future issue date because the invoice is scheduled to be sent through PayPal on that date.&lt;blockquote&gt;&lt;strong&gt;Notes:&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;After you send an invoice, resending it has no effect.&lt;/li&gt;&lt;li&gt;To send a notification for updates, &lt;a href&#x3D;\&quot;#invoices_update\&quot;&gt;update the invoice&lt;/a&gt; and set the &lt;code&gt;send_to_recipient&lt;/code&gt; body parameter to &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param notification The email or SMS notification to send to the payer when they send an invoice.. (optional)
   * @return CompletableFuture&lt;LinkDescription&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<LinkDescription> invoicesSend(String invoiceId, Notification notification) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesSendRequestBuilder(invoiceId, notification);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesSend", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<LinkDescription>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Send invoice
   * Sends or schedules an invoice, by ID, to be sent to a customer. The action depends on the invoice issue date:&lt;ul&gt;&lt;li&gt;If the invoice issue date is current or in the past, sends the invoice immediately.&lt;/li&gt;&lt;li&gt;If the invoice issue date is in the future, schedules the invoice to be sent on that date.&lt;/li&gt;&lt;/ul&gt;To suppress the merchant&#39;s email notification, set the &#x60;send_to_invoicer&#x60; body parameter to &#x60;false&#x60;. To send the invoice through a share link and not through PayPal, set the &lt;code&gt;send_to_recipient&lt;/code&gt; parameter to &lt;code&gt;false&lt;/code&gt; in the &lt;code&gt;notification&lt;/code&gt; object. The &lt;code&gt;send_to_recipient&lt;/code&gt; parameter does not apply to a future issue date because the invoice is scheduled to be sent through PayPal on that date.&lt;blockquote&gt;&lt;strong&gt;Notes:&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;After you send an invoice, resending it has no effect.&lt;/li&gt;&lt;li&gt;To send a notification for updates, &lt;a href&#x3D;\&quot;#invoices_update\&quot;&gt;update the invoice&lt;/a&gt; and set the &lt;code&gt;send_to_recipient&lt;/code&gt; body parameter to &lt;code&gt;true&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param notification The email or SMS notification to send to the payer when they send an invoice.. (optional)
   * @return CompletableFuture&lt;ApiResponse&lt;LinkDescription&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<LinkDescription>> invoicesSendWithHttpInfo(String invoiceId, Notification notification) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesSendRequestBuilder(invoiceId, notification);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesSend", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<LinkDescription>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<LinkDescription>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesSendRequestBuilder(String invoiceId, Notification notification) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesSend");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}/send"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, multipart/mixed");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(notification);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Fully update invoice
   * Fully updates an invoice, by ID. In the JSON request body, include a complete &#x60;invoice&#x60; object. This call does not support partial updates.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param invoice A representation of changes to make in the invoice. (required)
   * @param sendToRecipient Indicates whether to send the invoice update notification to the recipient. (optional, default to true)
   * @param sendToInvoicer Indicates whether to send the invoice update notification to the merchant. (optional, default to true)
   * @return CompletableFuture&lt;Invoice&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<Invoice> invoicesUpdate(String invoiceId, Invoice invoice, Boolean sendToRecipient, Boolean sendToInvoicer) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesUpdateRequestBuilder(invoiceId, invoice, sendToRecipient, sendToInvoicer);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesUpdate", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<Invoice>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Fully update invoice
   * Fully updates an invoice, by ID. In the JSON request body, include a complete &#x60;invoice&#x60; object. This call does not support partial updates.
   * @param invoiceId The ID of the draft invoice to delete. (required)
   * @param invoice A representation of changes to make in the invoice. (required)
   * @param sendToRecipient Indicates whether to send the invoice update notification to the recipient. (optional, default to true)
   * @param sendToInvoicer Indicates whether to send the invoice update notification to the merchant. (optional, default to true)
   * @return CompletableFuture&lt;ApiResponse&lt;Invoice&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<Invoice>> invoicesUpdateWithHttpInfo(String invoiceId, Invoice invoice, Boolean sendToRecipient, Boolean sendToInvoicer) throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicesUpdateRequestBuilder(invoiceId, invoice, sendToRecipient, sendToInvoicer);
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicesUpdate", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<Invoice>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<Invoice>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicesUpdateRequestBuilder(String invoiceId, Invoice invoice, Boolean sendToRecipient, Boolean sendToInvoicer) throws ApiException {
    // verify the required parameter 'invoiceId' is set
    if (invoiceId == null) {
      throw new ApiException(400, "Missing the required parameter 'invoiceId' when calling invoicesUpdate");
    }
    // verify the required parameter 'invoice' is set
    if (invoice == null) {
      throw new ApiException(400, "Missing the required parameter 'invoice' when calling invoicesUpdate");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/invoices/{invoice_id}"
        .replace("{invoice_id}", ApiClient.urlEncode(invoiceId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    StringJoiner localVarQueryStringJoiner = new StringJoiner("&");
    String localVarQueryParameterBaseName;
    localVarQueryParameterBaseName = "send_to_recipient";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("send_to_recipient", sendToRecipient));
    localVarQueryParameterBaseName = "send_to_invoicer";
    localVarQueryParams.addAll(ApiClient.parameterToPairs("send_to_invoicer", sendToInvoicer));

    if (!localVarQueryParams.isEmpty() || localVarQueryStringJoiner.length() != 0) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      if (localVarQueryStringJoiner.length() != 0) {
        queryJoiner.add(localVarQueryStringJoiner.toString());
      }
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json, multipart/mixed");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(invoice);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Generate invoice number
   * Generates the next invoice number that is available to the merchant. The next invoice number uses the prefix and suffix from the last invoice number and increments the number by one. For example, the next invoice number after &#x60;INVOICE-1234&#x60; is &#x60;INVOICE-1235&#x60;.
   * @return CompletableFuture&lt;InvoiceNumber&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<InvoiceNumber> invoicingGenerateNextInvoiceNumber() throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicingGenerateNextInvoiceNumberRequestBuilder();
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicingGenerateNextInvoiceNumber", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<InvoiceNumber>() {})
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
      });
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  /**
   * Generate invoice number
   * Generates the next invoice number that is available to the merchant. The next invoice number uses the prefix and suffix from the last invoice number and increments the number by one. For example, the next invoice number after &#x60;INVOICE-1234&#x60; is &#x60;INVOICE-1235&#x60;.
   * @return CompletableFuture&lt;ApiResponse&lt;InvoiceNumber&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public CompletableFuture<ApiResponse<InvoiceNumber>> invoicingGenerateNextInvoiceNumberWithHttpInfo() throws ApiException {
    try {
      HttpRequest.Builder localVarRequestBuilder = invoicingGenerateNextInvoiceNumberRequestBuilder();
      return memberVarHttpClient.sendAsync(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofString()).thenComposeAsync(localVarResponse -> {
            if (memberVarAsyncResponseInterceptor != null) {
              memberVarAsyncResponseInterceptor.accept(localVarResponse);
            }
            if (localVarResponse.statusCode()/ 100 != 2) {
              return CompletableFuture.failedFuture(getApiException("invoicingGenerateNextInvoiceNumber", localVarResponse));
            }
            try {
              String responseBody = localVarResponse.body();
              return CompletableFuture.completedFuture(
                  new ApiResponse<InvoiceNumber>(
                      localVarResponse.statusCode(),
                      localVarResponse.headers().map(),
                      responseBody == null || responseBody.isBlank() ? null : memberVarObjectMapper.readValue(responseBody, new TypeReference<InvoiceNumber>() {}))
              );
            } catch (IOException e) {
              return CompletableFuture.failedFuture(new ApiException(e));
            }
        }
      );
    }
    catch (ApiException e) {
      return CompletableFuture.failedFuture(e);
    }
  }

  private HttpRequest.Builder invoicingGenerateNextInvoiceNumberRequestBuilder() throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/v2/invoicing/generate-next-invoice-number";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
